#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from radar_msgs.msg import RadarTrackList
from inertial_msgs.msg import Pose
from vehiclecontrol.msg import Control
from geometry_msgs.msg import Point
import numpy as np

class AEBControllerNode(Node):
    def __init__(self):  # Fixed typo: was _init_
        super().__init__('aeb_controller1_radar_only')

        self.get_logger().info("AEBControllerNode initialization started.")

        # Publishers/Subscribers
        self.control_pub = self.create_publisher(Control, '/vehicle_control', 10)
        self.radar_sub = self.create_subscription(
            RadarTrackList, '/RadarObjects', self.radar_callback, 10)
        self.pose_sub = self.create_subscription(
            Pose, '/InertialData', self.pose_callback, 10)

        # Parameters
        self.max_throttle = 100.0
        self.max_brake = 100.0
        self.target_speed = 8.33333   # 30 km/h in m/s
        self.target_stop_distance = 6.0
        self.stop_tolerance = 2.0
        self.min_decel = 5.0
        self.max_decel = 8.0
        self.safe_ttc_threshold = 2.5
        self.emergency_ttc = 1.0
        self.warning_ttc = 3.0
        self.vehicle_width = 1.5
        self.target_width_car = 1.8
        self.target_width_bicycle = 0.7
        
        # State
        self.ego_velocity = 0.0
        self.distance_traveled = 0.0
        self.last_time = self.get_clock().now()
        self.current_distance = float('inf')
        self.relative_velocity = 0.0
        self.dt = 0.1
        self.current_ttc = float('inf')
        self.target_position = Point()
        self.stopped = False   # Latch for stop state
        self.braking_latch = False

        # ---- Latch for AEB stop ----
        self.latched_stop = False

        # Feedbacks from CarMaker (for tuning)
        self.q_gas = 0.0      # to be updated with feedback throttle (VC.Gas)
        self.q_brake = 0.0    # to be updated with feedback brake (VC.Brake)
        self.q_steering = 0.0 # to be updated with feedback steering (VC.Steer.Ang)

        self.get_logger().info("AEBControllerNode initialized.")

    def pose_callback(self, msg):
        current_time = self.get_clock().now()
        dt = (current_time - self.last_time).nanoseconds / 1e9
        self.last_time = current_time

        self.dt = dt
        
        self.ego_velocity = msg.velocity.x
        self.distance_traveled += self.ego_velocity * dt

        # Optionally, update feedbacks if available from pose or other feedback topic
        # self.q_gas = msg.gas_feedback
        # self.q_brake = msg.brake_feedback
        # self.q_steering = msg.steering_feedback

        self.get_logger().debug(
            f"[POSE] Ego velocity: {self.ego_velocity:.2f} m/s, Distance traveled: {self.distance_traveled:.2f} m"
        )

    def radar_callback(self, msg):
        self.get_logger().debug("[RADAR] Received radar message.")
        try:
            closest_obj = None
            min_distance = float('inf')

            for obj in msg.objects:
                if abs(obj.y_distance) < 3.0 and 0 < obj.x_distance < min_distance:
                    min_distance = obj.x_distance
                    closest_obj = obj

            if closest_obj:
                self.current_distance = closest_obj.x_distance
                # vx is usually the relative velocity in radar, negative means closing
                self.relative_velocity = -closest_obj.vx
                self.target_position = Point(
                    x=closest_obj.x_distance,
                    y=closest_obj.y_distance,
                    z=0.0
                )
                if self.relative_velocity > 0.1:
                    self.current_ttc = self.current_distance / self.relative_velocity
                else:
                    self.current_ttc = float('inf')
                self.get_logger().info(
                    f"[RADAR] Closest object: d={self.current_distance:.2f}m, y={closest_obj.y_distance:.2f}, rel_v={self.relative_velocity:.2f} m/s, TTC={self.current_ttc:.2f} s"
                )
            else:
                self.current_distance = float('inf')
                self.relative_velocity = 0.0
                self.current_ttc = float('inf')
                self.get_logger().info("[RADAR] No relevant object found.")

            self.execute_control()
        except Exception as e:
            self.get_logger().error(f"Radar processing error: {str(e)}")

    def calculate_overlap(self):
        ego_y = 0.0  # Assuming ego always centered at y=0; update if not
        target_y = self.target_position.y

        if self.current_distance < 20:
            target_width = self.target_width_bicycle
        else:
            target_width = self.target_width_car

        ego_left = ego_y - self.vehicle_width / 2
        ego_right = ego_y + self.vehicle_width / 2
        target_left = target_y - target_width / 2
        target_right = target_y + target_width / 2

        overlap_left = max(ego_left, target_left)
        overlap_right = min(ego_right, target_right)
        overlap_width = max(0.0, overlap_right - overlap_left)

        min_width = min(self.vehicle_width, target_width)
        overlap_fraction = overlap_width / min_width if min_width > 0 else 0.0

        self.get_logger().info(
            f"[OVERLAP] ego_y={ego_y:.2f}, ego_w={self.vehicle_width:.2f}, target_y={target_y:.2f}, target_w={target_width:.2f}, overlap_width={overlap_width:.2f}, overlap_fraction={overlap_fraction:.2f}"
        )
        return overlap_fraction

    def execute_control(self):
        control_msg = Control()
        control_msg.steering = 0.0
        control_msg.latswitch = 0
        control_msg.longswitch = 1

        # -- Latch check --
        if self.latched_stop:
            control_msg.throttle = 0.0
            control_msg.brake = self.max_brake
            self.publish_control(control_msg)
            self.get_logger().info("[AEB LATCH] Holding stop: Brake=100%, Throttle=0% due to previous AEB stop.")
            return

        self.get_logger().info(
            f"[CONTROL] V_ego={self.ego_velocity:.2f}m/s, d_traveled={self.distance_traveled:.2f}m, "
            f"d_obj={self.current_distance:.2f}m, ttc={self.current_ttc:.2f}s"
        )

        TTC_BRAKE_THRESHOLD = 1.5  # seconds

        # --- TTC BASED BRAKING ---
        if 0 < self.current_ttc < TTC_BRAKE_THRESHOLD:
            control_msg.throttle = 0.0
            # Use smooth brake to tune braking based on feedback
            control_msg.brake = self.smooth_brake(self.target_speed, self.dt)
            self.publish_control(control_msg)
            self.get_logger().warn(f"TTC={self.current_ttc:.2f}s < {TTC_BRAKE_THRESHOLD}s: BRAKE APPLIED (smooth tuning)!")
            # -- Set latch if stopped in the required zone --
            front_gap = self.current_distance
            stop_min = self.target_stop_distance - self.stop_tolerance  # 4m
            stop_max = self.target_stop_distance + self.stop_tolerance  # 8m
            if abs(self.ego_velocity) < 0.1 and stop_min <= front_gap <= stop_max:
                self.latched_stop = True
                self.get_logger().info("[AEB LATCH] Vehicle stopped in 4-8m gap. Latch engaged.")
            return

        # --- Clamp throttle so speed never exceeds target_speed ---
        if self.ego_velocity < self.target_speed - 0.1:
            # Proportional throttle control up to target speed
            speed_error = self.target_speed - self.ego_velocity
            throttle_cmd = np.clip((speed_error / self.target_speed) * self.max_throttle, 0, self.max_throttle)
            control_msg.throttle = throttle_cmd
            control_msg.brake = 0.0
            self.publish_control(control_msg)
            self.get_logger().info(f"[SPEED CTRL] Throttle: {control_msg.throttle:.2f}%, Target: {self.target_speed:.2f}m/s, Actual: {self.ego_velocity:.2f}m/s")
            return

        elif self.ego_velocity > self.target_speed + 0.2:
            # If speed overshoots, apply gentle brake to bring back to target
            control_msg.throttle = 0.0
            control_msg.brake = self.smooth_brake(self.target_speed, self.dt)
            self.publish_control(control_msg)
            self.get_logger().info(f"[SPEED CTRL] Speed > target. Applying brake to reduce from {self.ego_velocity:.2f} m/s")
            return

        else:
            # In speed window: keep throttle at zero, brake at zero
            control_msg.throttle = 0.0
            control_msg.brake = 0.0
            self.publish_control(control_msg)
            self.get_logger().info(f"[SPEED CTRL] Holding target speed. No throttle/brake.")
            return

    def publish_control(self, control_msg):
        self.get_logger().info(
            f"Publishing Control Command - Steering: {control_msg.steering}, "
            f"Throttle: {control_msg.throttle}, Brake: {control_msg.brake}, "
            f"LongSwitch: {control_msg.longswitch}, LatSwitch: {control_msg.latswitch}"
        )
        self.control_pub.publish(control_msg)

    def smooth_brake(self, target_velocity, dt):
        # PID constants (tune as needed)
        Kp = 30.0
        Ki = 5.0
        # No derivative term for now
        error = self.ego_velocity - target_velocity
        if not hasattr(self, "brake_integral"):
            self.brake_integral = 0.0
        self.brake_integral += error * dt
        brake_cmd = Kp * error + Ki * self.brake_integral
        brake_cmd = np.clip(brake_cmd, 0, self.max_brake)
        return brake_cmd

def main(args=None):
    rclpy.init(args=args)
    node = AEBControllerNode()
    node.get_logger().info("AEBControllerNode spinning. Waiting for data...")
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        node.get_logger().info("AEBControllerNode interrupted by user (KeyboardInterrupt).")
    finally:
        node.get_logger().info("AEBControllerNode shutting down, cleaning up.")
        node.destroy_node()
        rclpy.shutdown()
        print("AEBControllerNode terminated.")

if __name__ == '__main__':  # Fixed typo: was _name_ and _main_
    main()
